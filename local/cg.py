#AUTOGENERATED! DO NOT EDIT! File to edit: dev/GC.ipynb (unless otherwise specified).

__all__ = ['UnknownCGVar', 'NeverInitializedGcInput', 'BadlyNamedGcVar', 'PlaceHolderCGVal', 'CGVar']

#Cell
import inspect
import math
class UnknownCGVar(Exception): pass
class NeverInitializedGcInput(Exception): pass
class BadlyNamedGcVar(Exception): pass
class PlaceHolderCGVal(): pass

#Cell
class CGVar():
    def __init__(self,name:str, f = lambda:None,val = PlaceHolderCGVal(),is_input = False, deps : list = [],initialStep = 0):
        self.name = name
        self.f = f
        self.opt : bool = False
        self.deps : list = []
        self.str_deps : list= deps
        self._step_counter : int = initialStep
        self.val = val
        self.is_input = is_input
    def setVal(self,val):
        if val != self.val:
            self.val = val
            self.is_input = True
    def callTree(self,CG):
        if self.is_input: return self.name
        else: return [dep.callTree(CG) for dep in self.deps]
    def run(self, CG):
        if not self.is_input:
        #    if not self.has_changed and type(self.val) == PlaceHolderCGVal : raise NeverInitializedGcInput(f"'{name}' has never been initialized in this graph")
        #else:
            if self._step_counter >= CG._step_counter : return (self.val, self.in_deps)
            self._step_counter = CG._step_counter
            if self.opt : self._run_opt(CG)
            else :self._run_unopt(CG)
        return self.val
        #if self._step_counter < CG._step_counter :
        #    self._step_counter = CG._step_counter
        #    if self.is_input:
        #        if not self.has_changed and type(self.val) == PlaceHolderCGVal :
        #            raise NeverInitializedGcInput(f"'{name}' has never been initialized in this graph")
        #        self.has_changed = False
        #    else:
        #        if not self.opt : self._run_unopt(CG)
        #        else: self._run_opt(CG)
        #if self.is_input : return (self.val, [self])
        #else :  return (self.val, self.in_deps)

    def _run_unopt(self,CG):
        self.deps = []
        rets=[]
        for dep in self.str_deps:
            try : dep = CG._vars[dep]
            except KeyError : raise UnknownCGVar(f"'{name}' has never been declared in this graph")
            self.deps.append(dep)
            ret, in_dep = dep.run(CG)
            rets.append(ret)
        self.opt = True
        self.val = self.f(*rets)
    def _run_opt(self,CG):
        #needRecompute  = any([in_dep.has_changed for in_dep in self.in_deps])
        #if needRecompute:
        rets = [dep.run(CG) for dep in self.deps]
        #oldval = self.val
        self.val = self.f(*rets)
            #self.has_changed = (oldval != self.val)  if two values of an observable vars are the same, the observer won't be updated
    def __repr__(self):
        if self.is_input :
            ret = str(self.name) +"[label=\"" + str(self.name) + "\"]"
        else:
            ret = str(self.name) +"[label=\"" + str(self.name) + f" = f({', '.join(self.str_deps)})\"]"
            for dep in self.str_deps:
                ret +="\n" + dep + "->" + str(self.name) + f'[color="{"red" if hasattr(self.f, "_observes") and self.f._observes else "green"}"]'
        return ret